from dataclasses import dataclass

import torch
import torch.nn.functional as F

import nerfacc

import threestudio
from threestudio.utils.base import BaseModule
from threestudio.models.geometry import BaseImplicitGeometry
from threestudio.models.materials import BaseMaterial
from threestudio.models.background import BaseBackground
from threestudio.utils.typing import *
from threestudio.utils.ops import chunk_batch
from threestudio.utils.rasterize import NVDiffRasterizerContext
from threestudio.utils.misc import get_device


class Renderer(BaseModule):
    @dataclass
    class Config(BaseModule.Config):
        radius: float = 1.0

    cfg: Config

    def configure(self, geometry: BaseImplicitGeometry, material: BaseMaterial, background: BaseBackground) -> None:
        # keep references to submodules using namedtuple, avoid being registered as modules
        @dataclass
        class SubModules:
            geometry: BaseImplicitGeometry
            material: BaseMaterial
            background: BaseBackground
        self.sub_modules = SubModules(geometry, material, background)

        # set up bounding box
        self.bbox: Float[Tensor, "2 3"]
        self.register_buffer("bbox", torch.as_tensor(
            [
                [-self.cfg.radius, -self.cfg.radius, -self.cfg.radius],
                [self.cfg.radius, self.cfg.radius, self.cfg.radius],
            ],
            dtype=torch.float32,
        ))        
    
    def forward(self, *args, **kwargs) -> Dict[str, Any]:
        raise NotImplementedError

    @property
    def geometry(self) -> BaseImplicitGeometry:
        return self.sub_modules.geometry
    
    @property
    def material(self) -> BaseMaterial:
        return self.sub_modules.material
    
    @property
    def background(self) -> BaseBackground:
        return self.sub_modules.background
    
    def set_geometry(self, geometry: BaseImplicitGeometry) -> None:
        self.sub_modules.geometry = geometry
    
    def set_material(self, material: BaseMaterial) -> None:
        self.sub_modules.material = material
    
    def set_background(self, background: BaseBackground) -> None:
        self.sub_modules.background = background


class VolumeRenderer(Renderer):
    pass


class Rasterizer(Renderer):
    pass


@threestudio.register('nerf-volume-renderer')
class NeRFVolumeRenderer(VolumeRenderer):
    @dataclass
    class Config(VolumeRenderer.Config):
        num_samples_per_ray: int = 512
        randomized: bool = True
        eval_chunk_size: int = 8192
        grid_prune: bool = True
    
    cfg: Config

    def configure(self, geometry: BaseImplicitGeometry, material: BaseMaterial, background: BaseBackground) -> None:
        super().configure(geometry, material, background)
        self.estimator = nerfacc.OccGridEstimator(roi_aabb=self.bbox.view(-1), resolution=32, levels=1)
        if not self.cfg.grid_prune:
            self.estimator.occs.fill_(True)
            self.estimator.binaries.fill_(True)
        self.render_step_size = 1.732 * 2 * self.cfg.radius / self.cfg.num_samples_per_ray
        self.randomized = self.cfg.randomized

    def forward(self, rays_o: Float[Tensor, "B H W 3"], rays_d: Float[Tensor, "B H W 3"], light_positions: Float[Tensor, "B 3"], bg_color: Optional[Tensor] = None, **kwargs) -> Dict[str, Float[Tensor, "..."]]:
        batch_size, height, width = rays_o.shape[:3]
        rays_o_flatten: Float[Tensor, "Nr 3"] = rays_o.reshape(-1, 3)
        rays_d_flatten: Float[Tensor, "Nr 3"] = rays_d.reshape(-1, 3)
        light_positions_flatten: Float[Tensor, "Nr 3"] = light_positions.reshape(-1, 1, 1, 3).expand(-1, height, width, -1).reshape(-1, 3)
        n_rays = rays_o_flatten.shape[0]

        if not self.cfg.grid_prune:
            with torch.no_grad():
                ray_indices, t_starts_, t_ends_ = self.estimator.sampling(
                    rays_o_flatten, rays_d_flatten, sigma_fn=None, render_step_size=self.render_step_size,
                    alpha_thre=0., stratified=self.randomized, cone_angle=0., early_stop_eps=0,
                )
        else:
            def sigma_fn(t_starts, t_ends, ray_indices):
                ray_indices = ray_indices.long()
                t_origins = rays_o_flatten[ray_indices]
                t_dirs = rays_d_flatten[ray_indices]
                positions = t_origins + t_dirs * (t_starts[...,None] + t_ends[...,None]) / 2.
                density = self.geometry.forward_density(positions)
                return density[...,0]
            with torch.no_grad():
                ray_indices, t_starts_, t_ends_ = self.estimator.sampling(
                    rays_o_flatten, rays_d_flatten, sigma_fn=sigma_fn, render_step_size=self.render_step_size,
                    alpha_thre=0., stratified=self.randomized, cone_angle=0.
                )


        ray_indices = ray_indices.long()
        t_starts, t_ends = t_starts_[...,None], t_ends_[...,None]
        t_origins = rays_o_flatten[ray_indices]
        t_dirs = rays_d_flatten[ray_indices]
        t_light_positions = light_positions_flatten[ray_indices]
        t_positions = (t_starts + t_ends) / 2.
        positions = t_origins + t_dirs * t_positions
        t_intervals = t_ends - t_starts

        # TODO: still proceed if the scene is empty 

        if self.training:
            geo_out = self.geometry(positions, output_normal=self.material.requires_normal)
            rgb_fg_all = self.material(viewdirs=t_dirs, positions=positions, light_positions=t_light_positions, **geo_out, **kwargs)
            comp_rgb_bg = self.background(dirs=rays_d_flatten)
        else:
            geo_out = chunk_batch(self.geometry, self.cfg.eval_chunk_size, positions, output_normal=self.material.requires_normal)
            rgb_fg_all = chunk_batch(self.material, self.cfg.eval_chunk_size, viewdirs=t_dirs, positions=positions, light_positions=t_light_positions, **geo_out)
            comp_rgb_bg = chunk_batch(self.background, self.cfg.eval_chunk_size, dirs=rays_d_flatten)

        weights: Float[Tensor, "Nr 1"]
        weights_, _, _ = nerfacc.render_weight_from_density(t_starts[...,0], t_ends[...,0], geo_out['density'][...,0], ray_indices=ray_indices, n_rays=n_rays)
        weights = weights_[...,None]
        opacity: Float[Tensor, "Nr 1"] = nerfacc.accumulate_along_rays(weights[...,0], values=None, ray_indices=ray_indices, n_rays=n_rays)
        depth: Float[Tensor, "Nr 1"] = nerfacc.accumulate_along_rays(weights[...,0], values=t_positions, ray_indices=ray_indices, n_rays=n_rays)
        comp_rgb_fg: Float[Tensor, "Nr Nc"] = nerfacc.accumulate_along_rays(weights[...,0], values=rgb_fg_all, ray_indices=ray_indices, n_rays=n_rays)
        
        if bg_color is None:
            bg_color = comp_rgb_bg
        else:
            if bg_color.shape == (batch_size, height, width, 3):
                bg_color = bg_color.reshape(-1, 3)

        comp_rgb = comp_rgb_fg + bg_color * (1.0 - opacity)    

        out = {
            'comp_rgb': comp_rgb.view(batch_size, height, width, -1),
            'comp_rgb_fg': comp_rgb_fg.view(batch_size, height, width, -1),
            'comp_rgb_bg': comp_rgb_bg.view(batch_size, height, width, -1),
            'opacity': opacity.view(batch_size, height, width, 1),
            'depth': depth.view(batch_size, height, width, 1)
        }

        if self.training:
            out.update({
                'weights': weights,
                't_points': t_positions,
                't_intervals': t_intervals,
                't_dirs': t_dirs,
                'ray_indices': ray_indices,
                **geo_out
            })
        else:
            if 'normal' in geo_out:
                comp_normal: Float[Tensor, "Nr 3"] = nerfacc.accumulate_along_rays(weights[...,0], values=geo_out['normal'], ray_indices=ray_indices, n_rays=n_rays)
                comp_normal = F.normalize(comp_normal, dim=-1)
                comp_normal = (comp_normal + 1.) / 2. * opacity # for visualization
                out.update({
                    'comp_normal': comp_normal.view(batch_size, height, width, 3),
                })
        
        return out

    
    def update_step(self, epoch: int, global_step: int) -> None:
        if self.cfg.grid_prune:
            def occ_eval_fn(x):
                density = self.geometry.forward_density(x)
                # approximate for 1 - torch.exp(-density * self.render_step_size) based on taylor series
                return density * self.render_step_size
            
            if self.training:
                self.estimator.update_every_n_steps(step=global_step, occ_eval_fn=occ_eval_fn)
    
    def train(self, mode=True):
        self.randomized = mode and self.cfg.randomized
        return super().train(mode=mode)
    
    def eval(self):
        self.randomized = False
        return super().eval()


class NeuSVolumeRenderer(VolumeRenderer):
    pass

class DeferredVolumeRenderer(VolumeRenderer):
    pass


@threestudio.register('nvdiff-rasterizer')
class NVDiffRasterizer(Rasterizer):
    @dataclass
    class Config(VolumeRenderer.Config):
        context_type: str = "gl"
    
    cfg: Config

    def configure(self, geometry: BaseImplicitGeometry, material: BaseMaterial, background: BaseBackground) -> None:
        super().configure(geometry, material, background)
        self.ctx = NVDiffRasterizerContext(self.cfg.context_type, get_device())
    
    def forward(self, mvp_mtx: Float[Tensor, "B 4 4"], camera_positions: Float[Tensor, "B 3"], light_positions: Float[Tensor, "B 3"], height: int, width: int, render_normal: bool = True, render_rgb: bool = True, **kwargs) -> Dict[str, Any]:
        batch_size = mvp_mtx.shape[0]
        mesh = self.geometry.isosurface()

        v_pos_clip: Float[Tensor, "B Nv 4"] = self.ctx.vertex_transform(mesh.v_pos, mvp_mtx)
        rast, _ = self.ctx.rasterize(v_pos_clip, mesh.t_pos_idx, (height, width))
        mask = rast[...,3:] > 0
        mask_aa = self.ctx.antialias(mask.float(), rast, v_pos_clip, mesh.t_pos_idx)

        out = {
            'opacity': mask_aa,
            'mesh': mesh
        }

        if render_normal:
            gb_normal, _ = self.ctx.interpolate_one(mesh.v_nrm, rast, mesh.t_pos_idx)
            gb_normal = F.normalize(gb_normal, dim=-1)
            gb_normal_aa = torch.lerp(torch.zeros_like(gb_normal), (gb_normal + 1.) / 2., mask.float())
            gb_normal_aa = self.ctx.antialias(gb_normal_aa, rast, v_pos_clip, mesh.t_pos_idx)
            out.update({
                'comp_normal': gb_normal_aa # in [0, 1]
            })

        if render_rgb:
            selector = mask[...,0]

            gb_pos, _ = self.ctx.interpolate_one(mesh.v_pos, rast, mesh.t_pos_idx)
            gb_viewdirs = F.normalize(gb_pos - camera_positions[:,None,None,:], dim=-1)
            gb_light_positions = light_positions[:,None,None,:].expand(-1, height, width, -1)

            positions = gb_pos[selector]
            geo_out = self.geometry(positions, output_normal=False)
            rgb_fg = self.material(viewdirs=gb_viewdirs[selector], positions=positions, light_positions=gb_light_positions[selector], shading_normal=gb_normal[selector], **geo_out)
            gb_rgb_fg = torch.zeros(batch_size, height, width, 3).to(rgb_fg)
            gb_rgb_fg[selector] = rgb_fg

            gb_rgb_bg = self.background(dirs=gb_viewdirs)
            gb_rgb = torch.lerp(gb_rgb_bg, gb_rgb_fg, mask.float())
            gb_rgb_aa = self.ctx.antialias(gb_rgb, rast, v_pos_clip, mesh.t_pos_idx)

            out.update({
                'comp_rgb': gb_rgb_aa
            })

        return out
